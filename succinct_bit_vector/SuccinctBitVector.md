# Succinct Bit Vector (Лаконичный Битовый Вектор)

Succinct Bit Vector — это пространственно-эффективная структура данных, позволяющая хранить битовый массив длины $N$, занимая $N + o(N)$
памяти, и поддерживающая операции Rank и Select за время $O(1)$.

Является фундаментальным строительным блоком для структур данных, описанных в
статье [Approximate Range Emptiness in Constant Time and Optimal Space](https://arxiv.org/pdf/1407.2907)
(в частности, для структур $D_1$ и $D_2$, see [## Использование в ExactRangeEmptiness]).

## Основные Операции

| Операция   | Описание                                                            | Сложность |
|:-----------|:--------------------------------------------------------------------|:----------|
| Access(i)  | Возвращает значение бита по индексу $i$ ($0$ или $1$).              | $O(1)$    |
| Rank1(i)   | Возвращает количество установленных бит ($1$) в диапазоне $[0, i)$. | $O(1)$    |
| Select1(k) | Возвращает индекс $k$-й установленной единицы в массиве.            | $O(1)^*$  |

* Примечание: В базовой реализации Select1 может выполняться за $O(\lg N)$ через бинарный поиск по Rank1, что допустимо для первой версии.
  Оптимизированная версия требует дополнительной индексации.

## Внутренняя Архитектура

Для достижения константного времени выполнения Rank1 используется двухуровневая схема индексации (Jaconson's Rank structure).

1. **Данные (Raw Data)**

   Исходные биты хранятся упакованными в массив машинных слов (например, uint64 или Long).

    * Word Size ($w$): 64 бита.

2. **Уровень 1: Суперблоки (Superblocks)**

   Массив разбивается на крупные сегменты — суперблоки.

    * Размер: Обычно $L1 = w^2$ (например, 512 или 1024 бита).
    * Хранение: Массив `superblocks[]`. Каждый элемент хранит абсолютное значение Rank (общее количество единиц) от начала вектора до начала
      данного суперблока.
    * Тип данных: `uint64` (так как значение может достигать $N$).

3. **Уровень 2: Блоки (Blocks)**

   Каждый суперблок разбивается на мелкие блоки.

    * Размер: Обычно $L2 = w$ (64 бита), совпадает с машинным словом для эффективности Popcount.
    * Хранение: Массив `blocks[]`. Каждый элемент хранит относительное значение Rank (количество единиц) от начала текущего суперблока до
      начала данного блока.
    * Тип данных: `uint16` (так как значение не превышает размер суперблока).

## Алгоритм Rank1

Вычисление `Rank1(i)` состоит из суммирования трех компонентов:

$$\text{Rank1}(i) = \text{Superblock}[i / L1] + \text{Block}[i / L2] + \text{Popcount}(\text{Word} \ \& \ \text{Mask})$$

* База: Значение из массива суперблоков по индексу $i / L1$.
* Смещение: Значение из массива блоков по индексу $i / L2$.
* Локальный подсчет: Подсчет единиц (Popcount) внутри конкретного 64-битного слова, содержащего бит $i$, маскируя биты старше $i \% 64$.

## Спецификация API

Ниже приведено описание интерфейса модуля.

### Конструктор / Build

```go
// Строит вспомогательные индексы (суперблоки и блоки) на основе переданных битов.
// Вход: data - массив uint64, n - количество значащих бит.
// Сложность: O(N)
func NewSuccinctBitVector(data []uint64, n int) *SuccinctBitVector
```

### Методы

```go
// Возвращает true, если бит i установлен в 1.
func (bv *SuccinctBitVector) Access(i int) bool

// Возвращает количество единиц в диапазоне [0, i).
// Если i выходит за границы, поведение не определено (или panic).
func (bv *SuccinctBitVector) Rank1(i int) int

// Возвращает индекс k-й единицы (1-based index).
// Если k больше общего количества единиц, возвращает -1.
func (bv *SuccinctBitVector) Select1(k int) int
```

## Использование в ExactRangeEmptiness

В контексте задачи Range Emptiness, структура используется для двух целей:

* **D1 (Битовая карта поддиапазонов):**

    * Размер: $N$ бит (где $N$ — количество поддиапазонов).
    * Использование: Rank1 позволяет мгновенно проверить, есть ли заполненные поддиапазоны между индексами $i$ и $j$ (проверка
      `Rank1(j) - Rank1(i+1) > 0`).

* **D2 (Карта смещений):**

    * Размер: $\approx 2N$ бит.
    * Использование: Реализует отображение разреженных индексов в плотный массив. Использует Select1 для нахождения позиции начала данных
      для $k$-го непустого поддиапазона.